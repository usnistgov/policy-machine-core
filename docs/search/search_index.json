{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The purpose of Policy Machine Core project is to provide a bare bones library for NGAC. This library includes interfaces to interact with NGAC components,simple implementations of those interfaces, and algorithms to query the state of a graph. This is a great place to start experimenting with NGAC and different policy configurations.","title":"Introduction"},{"location":"contact/","text":"Contact Us David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"contact/#contact-us","text":"David Ferraiolo - david.ferraiolo@nist.gov (Group Manager) Serban Gavrila - serban.gavrila@nist.gov (Developer) Gopi Katwala - gopi.katwala@nist.gov (Developer) Joshua Roberts - joshua.roberts@nist.gov (Developer)","title":"Contact Us"},{"location":"examples/","text":"Examples Serialization Graph Serialize a graph into a json string. Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json); Prohibitions Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json); Bank Teller Graph configuration summary Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Access control state u1 can read and write o1 u2 can read o1 Code Wakthrough // 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(tellerNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(auditorNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); Visualization Below is a visual representation of the graph created in the bank teller example. Employee Record Example configuration summary One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries. Access control state Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes Node salariesNode = graph.createNode(rand.nextLong(), \"Salaries\", OA, null); Node ssnsNode = graph.createNode(rand.nextLong(), \"SSNs\", OA, null); Node grp1SalariesNode = graph.createNode(rand.nextLong(), \"Grp1 Salaries\", OA, null); Node grp2SalariesNode = graph.createNode(rand.nextLong(), \"Grp2 Salaries\", OA, null); Node publicNode = graph.createNode(rand.nextLong(), \"Public Info\", OA, null); Node bobRecNode = graph.createNode(rand.nextLong(), \"Bob Record\", OA, null); Node bobRNode = graph.createNode(rand.nextLong(), \"Bob r\", OA, null); Node bobRWNode = graph.createNode(rand.nextLong(), \"Bob r/w\", OA, null); Node aliceRecNode = graph.createNode(rand.nextLong(), \"Alice Record\", OA, null); Node aliceRNode = graph.createNode(rand.nextLong(), \"Alice r\", OA, null); Node aliceRWNode = graph.createNode(rand.nextLong(), \"Alice r/w\", OA, null); // objects for bob's name, salary, and ssn Node bobNameNode = graph.createNode(rand.nextLong(), \"bob name\", O, null); Node bobSalaryNode = graph.createNode(rand.nextLong(), \"bob salary\", O, null); Node bobSSNNode = graph.createNode(rand.nextLong(), \"bob ssn\", O, null); // objects for alice's name, salary, and ssn Node aliceNameNode = graph.createNode(rand.nextLong(), \"alice name\", O, null); Node aliceSalaryNode = graph.createNode(rand.nextLong(), \"alice salary\", O, null); Node aliceSSNNode = graph.createNode(rand.nextLong(), \"alice ssn\", O, null); // user attributes Node hrNode = graph.createNode(rand.nextLong(), \"HR\", UA, null); Node grp1MgrNode = graph.createNode(rand.nextLong(), \"Grp1Mgr\", UA, null); Node grp2MgrNode = graph.createNode(rand.nextLong(), \"Grp2Mgr\", UA, null); Node staffNode = graph.createNode(rand.nextLong(), \"Staff\", UA, null); Node bobUANode = graph.createNode(rand.nextLong(), \"Bob\", UA, null); Node aliceUANode = graph.createNode(rand.nextLong(), \"Alice\", UA, null); // users Node bobNode = graph.createNode(rand.nextLong(), \"bob\", U, null); Node aliceNode = graph.createNode(rand.nextLong(), \"alice\", U, null); Node charlieNode = graph.createNode(rand.nextLong(), \"charlie\", U, null); // policy class Node pcNode = graph.createNode(rand.nextLong(), \"Employee Records\", PC, null); // assignments // assign users to user attributes graph.assign(charlieNode.getID(), hrNode.getID()); graph.assign(bobNode.getID(), grp1MgrNode.getID()); graph.assign(aliceNode.getID(), grp2MgrNode.getID()); graph.assign(charlieNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), staffNode.getID()); graph.assign(aliceNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), bobUANode.getID()); graph.assign(aliceNode.getID(), aliceUANode.getID()); // assign objects to object attributes // salary objects graph.assign(bobSalaryNode.getID(), salariesNode.getID()); graph.assign(bobSalaryNode.getID(), grp1SalariesNode.getID()); graph.assign(bobSalaryNode.getID(), bobRNode.getID()); graph.assign(aliceSalaryNode.getID(), salariesNode.getID()); graph.assign(aliceSalaryNode.getID(), grp2SalariesNode.getID()); graph.assign(aliceSalaryNode.getID(), aliceRNode.getID()); // ssn objects graph.assign(bobSSNNode.getID(), ssnsNode.getID()); graph.assign(bobSSNNode.getID(), bobRWNode.getID()); graph.assign(aliceSSNNode.getID(), aliceNode.getID()); graph.assign(aliceSSNNode.getID(), aliceRWNode.getID()); // name objects graph.assign(bobNameNode.getID(), publicNode.getID()); graph.assign(bobNameNode.getID(), bobRWNode.getID()); graph.assign(aliceNameNode.getID(), publicNode.getID()); graph.assign(aliceNameNode.getID(), aliceRWNode.getID()); // bob and alice r/w containers to their records graph.assign(bobRNode.getID(), bobRecNode.getID()); graph.assign(bobRWNode.getID(), bobRecNode.getID()); graph.assign(aliceRNode.getID(), aliceRecNode.getID()); graph.assign(aliceRWNode.getID(), aliceRecNode.getID()); // assign object attributes to policy classes graph.assign(salariesNode.getID(), pcNode.getID()); graph.assign(ssnsNode.getID(), pcNode.getID()); graph.assign(grp1SalariesNode.getID(), pcNode.getID()); graph.assign(grp2SalariesNode.getID(), pcNode.getID()); graph.assign(publicNode.getID(), pcNode.getID()); graph.assign(bobRecNode.getID(), pcNode.getID()); graph.assign(aliceRecNode.getID(), pcNode.getID()); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(hrNode.getID(), salariesNode.getID(), rw); graph.associate(hrNode.getID(), ssnsNode.getID(), rw); graph.associate(grp1MgrNode.getID(), grp1SalariesNode.getID(), r); graph.associate(grp2MgrNode.getID(), grp2SalariesNode.getID(), r); graph.associate(staffNode.getID(), publicNode.getID(), r); graph.associate(bobUANode.getID(), bobRWNode.getID(), rw); graph.associate(bobUANode.getID(), bobRNode.getID(), r); graph.associate(aliceUANode.getID(), aliceRWNode.getID(), rw); graph.associate(aliceUANode.getID(), aliceRNode.getID(), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobNode.getID(), bobSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobNode.getID(), bobSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); Visualization Below is a visual representation of the graph created in the employee record example. Audit Explain Using the bank teller example described above , auditor.explain(user1Node.getID(), objectNode.getID()) will result in: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w]","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#serialization","text":"","title":"Serialization"},{"location":"examples/#graph","text":"Serialize a graph into a json string. Graph graph = new MemGraph(); --- String json = GraphSerializer.toJson(graph); Deserialize a json string to a graph. Graph graph = GraphSerializer.fromJson(new MemGraph(), json);","title":"Graph"},{"location":"examples/#prohibitions","text":"Serialize a ProhibitionDAO into a json string. ProhibitionsDAO dao = new MemProhibitionsDAO(); --- String json = ProhibitionsSerializer.toJson(dao); Deserialize a json string to a ProhibitionsDAO. ProhibitionsDAO deDao = ProhibitionsSerializer.fromJson(new MemProhibitionsDAO(), json);","title":"Prohibitions"},{"location":"examples/#bank-teller","text":"","title":"Bank Teller"},{"location":"examples/#graph-configuration-summary","text":"Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute","title":"Graph configuration summary"},{"location":"examples/#access-control-state","text":"u1 can read and write o1 u2 can read o1","title":"Access control state"},{"location":"examples/#code-wakthrough","text":"// 1. Create a new Graph instance. For this example, we'll use the `MemGraph` which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); // 2. Create the user nodes `u1` and `u2`. Node user1Node = graph.createNode(rand.nextLong(), \"u1\", U, null); Node user2Node = graph.createNode(rand.nextLong(), \"u2\", U, null); // 3. Create the object, `o1` that will be the target of the access queries. Node objectNode = graph.createNode(rand.nextLong(), \"o1\", O, null); // 4. Create the `RBAC` policy class node. Node rbacNode = graph.createNode(rand.nextLong(), \"RBAC\", PC, null); // 5. Create an object attribute for the `Accounts`. Node accountsNode = graph.createNode(rand.nextLong(), \"Accounts\", OA, null); // 6. Create the `Teller` and `Auditor` user attributes. Node tellerNode = graph.createNode(rand.nextLong(), \"Teller\", UA, null); Node auditorNode = graph.createNode(rand.nextLong(), \"Auditor\", UA, null); // 7. Assign the `Accounts` object attribute to the `RBAC` policy class node. graph.assign(accountsNode.getID(), rbacNode.getID()); // 8. Assign the object, `o1`, to the `Accounts` object attribute. graph.assign(objectNode.getID(), accountsNode.getID()); // 9. Assign `u1` to the `Teller` user attribute and `u2` to the `Auditor` user attribute. graph.assign(user1Node.getID(), tellerNode.getID()); graph.assign(user2Node.getID(), auditorNode.getID()); // 10. Create the associations for `Teller` and `Auditor` on `Account` in RBAC. `Teller` has read and write permissions, while `Auditor` just has read permissions. graph.associate(tellerNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(auditorNode.getID(), accountsNode.getID(), new HashSet<>(Arrays.asList(\"r\"))); // 11. Create the `Branches` policy class. Node branchesNode = graph.createNode(rand.nextLong(), \"branches\", PC, null); // 12. Create an object attribute for `Branch 1`. Node branch1OANode = graph.createNode(rand.nextLong(), \"branch 1\", OA, null); // 13. Assign the branch 1 OA to the branches PC graph.assign(branch1OANode.getID(), branchesNode.getID()); // 14. Create the `Branch 1` user attribute Node branches1UANode = graph.createNode(rand.nextLong(), \"branch 1\", UA, null); // 15. Assign the object, `o1`, to the `Branch 1` object attribute graph.assign(objectNode.getID(), branch1OANode.getID()); // 16. Assign the users, `u1` and `u2`, to the branch 1 user attribute graph.assign(user1Node.getID(), branches1UANode.getID()); graph.assign(user2Node.getID(), branches1UANode.getID()); // 17. Create an association between the `branch 1` user attribute and the `branch 1` object attribute. //This will give both users read and write on `o1` under the `branches` policy class. graph.associate(branches1UANode.getID(), branch1OANode.getID(), new HashSet<>(Arrays.asList(\"r\", \"w\"))); // 18. Test the configuration using the `PReviewDecider` implementation of the `Decider` interface. //The constructor for a `PReviewDecider` receives the graph we created and a list of prohibitions. //Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph); // 19. Check that `u1` has read and write permissions on `o1`. Set<String> permissions = decider.listPermissions(user1Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // 20. Check that `u1` has read permissions on `o1`. permissions = decider.listPermissions(user2Node.getID(), objectNode.getID()); assertTrue(permissions.contains(\"r\"));","title":"Code Wakthrough"},{"location":"examples/#visualization","text":"Below is a visual representation of the graph created in the bank teller example.","title":"Visualization"},{"location":"examples/#employee-record","text":"","title":"Employee Record"},{"location":"examples/#example-configuration-summary","text":"One policy class Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries.","title":"Example configuration summary"},{"location":"examples/#access-control-state_1","text":"Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes Node salariesNode = graph.createNode(rand.nextLong(), \"Salaries\", OA, null); Node ssnsNode = graph.createNode(rand.nextLong(), \"SSNs\", OA, null); Node grp1SalariesNode = graph.createNode(rand.nextLong(), \"Grp1 Salaries\", OA, null); Node grp2SalariesNode = graph.createNode(rand.nextLong(), \"Grp2 Salaries\", OA, null); Node publicNode = graph.createNode(rand.nextLong(), \"Public Info\", OA, null); Node bobRecNode = graph.createNode(rand.nextLong(), \"Bob Record\", OA, null); Node bobRNode = graph.createNode(rand.nextLong(), \"Bob r\", OA, null); Node bobRWNode = graph.createNode(rand.nextLong(), \"Bob r/w\", OA, null); Node aliceRecNode = graph.createNode(rand.nextLong(), \"Alice Record\", OA, null); Node aliceRNode = graph.createNode(rand.nextLong(), \"Alice r\", OA, null); Node aliceRWNode = graph.createNode(rand.nextLong(), \"Alice r/w\", OA, null); // objects for bob's name, salary, and ssn Node bobNameNode = graph.createNode(rand.nextLong(), \"bob name\", O, null); Node bobSalaryNode = graph.createNode(rand.nextLong(), \"bob salary\", O, null); Node bobSSNNode = graph.createNode(rand.nextLong(), \"bob ssn\", O, null); // objects for alice's name, salary, and ssn Node aliceNameNode = graph.createNode(rand.nextLong(), \"alice name\", O, null); Node aliceSalaryNode = graph.createNode(rand.nextLong(), \"alice salary\", O, null); Node aliceSSNNode = graph.createNode(rand.nextLong(), \"alice ssn\", O, null); // user attributes Node hrNode = graph.createNode(rand.nextLong(), \"HR\", UA, null); Node grp1MgrNode = graph.createNode(rand.nextLong(), \"Grp1Mgr\", UA, null); Node grp2MgrNode = graph.createNode(rand.nextLong(), \"Grp2Mgr\", UA, null); Node staffNode = graph.createNode(rand.nextLong(), \"Staff\", UA, null); Node bobUANode = graph.createNode(rand.nextLong(), \"Bob\", UA, null); Node aliceUANode = graph.createNode(rand.nextLong(), \"Alice\", UA, null); // users Node bobNode = graph.createNode(rand.nextLong(), \"bob\", U, null); Node aliceNode = graph.createNode(rand.nextLong(), \"alice\", U, null); Node charlieNode = graph.createNode(rand.nextLong(), \"charlie\", U, null); // policy class Node pcNode = graph.createNode(rand.nextLong(), \"Employee Records\", PC, null); // assignments // assign users to user attributes graph.assign(charlieNode.getID(), hrNode.getID()); graph.assign(bobNode.getID(), grp1MgrNode.getID()); graph.assign(aliceNode.getID(), grp2MgrNode.getID()); graph.assign(charlieNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), staffNode.getID()); graph.assign(aliceNode.getID(), staffNode.getID()); graph.assign(bobNode.getID(), bobUANode.getID()); graph.assign(aliceNode.getID(), aliceUANode.getID()); // assign objects to object attributes // salary objects graph.assign(bobSalaryNode.getID(), salariesNode.getID()); graph.assign(bobSalaryNode.getID(), grp1SalariesNode.getID()); graph.assign(bobSalaryNode.getID(), bobRNode.getID()); graph.assign(aliceSalaryNode.getID(), salariesNode.getID()); graph.assign(aliceSalaryNode.getID(), grp2SalariesNode.getID()); graph.assign(aliceSalaryNode.getID(), aliceRNode.getID()); // ssn objects graph.assign(bobSSNNode.getID(), ssnsNode.getID()); graph.assign(bobSSNNode.getID(), bobRWNode.getID()); graph.assign(aliceSSNNode.getID(), aliceNode.getID()); graph.assign(aliceSSNNode.getID(), aliceRWNode.getID()); // name objects graph.assign(bobNameNode.getID(), publicNode.getID()); graph.assign(bobNameNode.getID(), bobRWNode.getID()); graph.assign(aliceNameNode.getID(), publicNode.getID()); graph.assign(aliceNameNode.getID(), aliceRWNode.getID()); // bob and alice r/w containers to their records graph.assign(bobRNode.getID(), bobRecNode.getID()); graph.assign(bobRWNode.getID(), bobRecNode.getID()); graph.assign(aliceRNode.getID(), aliceRecNode.getID()); graph.assign(aliceRWNode.getID(), aliceRecNode.getID()); // assign object attributes to policy classes graph.assign(salariesNode.getID(), pcNode.getID()); graph.assign(ssnsNode.getID(), pcNode.getID()); graph.assign(grp1SalariesNode.getID(), pcNode.getID()); graph.assign(grp2SalariesNode.getID(), pcNode.getID()); graph.assign(publicNode.getID(), pcNode.getID()); graph.assign(bobRecNode.getID(), pcNode.getID()); graph.assign(aliceRecNode.getID(), pcNode.getID()); // associations Set<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); Set<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(hrNode.getID(), salariesNode.getID(), rw); graph.associate(hrNode.getID(), ssnsNode.getID(), rw); graph.associate(grp1MgrNode.getID(), grp1SalariesNode.getID(), r); graph.associate(grp2MgrNode.getID(), grp2SalariesNode.getID(), r); graph.associate(staffNode.getID(), publicNode.getID(), r); graph.associate(bobUANode.getID(), bobRWNode.getID(), rw); graph.associate(bobUANode.getID(), bobRNode.getID(), r); graph.associate(aliceUANode.getID(), aliceRWNode.getID(), rw); graph.associate(aliceUANode.getID(), aliceRNode.getID(), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] Set<String> permissions = decider.listPermissions(bobNode.getID(), bobSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobNode.getID(), bobSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceNode.getID(), aliceSSNNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieNode.getID(), aliceSalaryNode.getID()); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\"));","title":"Access control state"},{"location":"examples/#visualization_1","text":"Below is a visual representation of the graph created in the employee record example.","title":"Visualization"},{"location":"examples/#audit","text":"","title":"Audit"},{"location":"examples/#explain","text":"Using the bank teller example described above , auditor.explain(user1Node.getID(), objectNode.getID()) will result in: operations: [r, w] policyClasses: RBAC operations: [r, w] paths: - u1-Teller-Accounts-o1 ops=[r, w] branches operations: [r, w] paths: - u1-branch 1-branch 1-o1 ops=[r, w]","title":"Explain"},{"location":"installation/","text":"Install using Maven Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>1.3.1</version> </dependency> That's it, now the policy-machine-core library will be available for use!","title":"Installation"},{"location":"installation/#install-using-maven","text":"Policy Machine Core uses JitPack to compile and build the artifact to import into projects. First, add jitpack as a repository <project> -- <repositories> <repository> <id>jitpack.io</id> <url>https://jitpack.io</url> </repository> </repositories> -- </project> Then, add the maven dependency <dependency> <groupId>com.github.PM-Master</groupId> <artifactId>policy-machine-core</artifactId> <version>1.3.1</version> </dependency> That's it, now the policy-machine-core library will be available for use!","title":"Install using Maven"},{"location":"obligations/","text":"Obligations Obligations are defined using a yaml syntax described below. Common Elements Nodes A node represents a node in an NGAC graph. A node has a name, type, and properties. A node can also be derived from a function. name: type: properties: - key: value function A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Example function: name: args: - \"\" - function: A function has a name and a list of arguments. The arguments are a list of string values or other functions. Obligation There is one obligation per yaml file. An obligation can have zero or more rules. label: rules: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules. Rule label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event. Event Pattern event: subject: policyClass: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine. Subject subject: user: any_user: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event. user A user is identified by it's name. any_user any_user: The any_user element accepts an array of strings representing user names. If the element is empty then any user will match. process process: The process element accepts a number as a process ID. Example: any_user: # any user ### any_user: # u1 or u2 - \"u1\" - \"u2\" process: 12345 Policy Class policy_class: anyOf: --- eachOf: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Only one of anyOf and eachOf are allowed. Example ### policyClass: # a;; policy class ### policyClass: # PC1 or PC2 anyOf: - \"PC1\" - \"PC2\" ### policyClass: # PC1 and PC2 eachOf: - \"PC1\" - \"PC2\" Operations operations: - \"operation_name\" The operations specification is a string array of operation names. Any event that matches an element of the array will match the operations event pattern. Example: operations: - \"read\" - \"write\" Target The target of an event can be A specific policy element policyElements: - name: name type: type Any policy element policyElements: * Omitting policyElements will have the same effect Any policy element that is contained in other policy elements containers: - name: type: - name: type: Any policy element from a set of policy elements policyElements: - name: name type: type - name: name type: type If both policyElements and containers are omitted it will be \"any policyElement in any container\" If containers is present then it will be \"any policyElement in the containers\", regardless of if policyElements is present If policyElements is present its \"any policyElement from the list provided\" Response A response is a series of conditional actions. A condition can also be applied to the response itself. Condition A condition is a set of boolean expressions that if all evaluate to true, allow for a response or specific action to be executed. condition: - function: - function: Create Action Create 1. A rule 2. A set of nodes and assign them to a set of containers rule create: rule: label: event: response: nodes Creating nodes requires the name and type of the nodes to create and the containers in which to assign them. A node can be specified with a set of properties if applicable. create: what: - name: node1 type: UA where: - name: container1 type: UA Assign Action assign: what: where: The what and where elements are arrays of nodes. The nodes in what will be assigned to the nodes in where . Grant Action Associate each node in subjects with each node in targets . grant: subjects: operations: targets: subjects is an array of nodes that will be the subject of the associations created. operations is an array of operations to add to the associations. targets is an array of nodes that will be the targets of the associations. Deny Action Deny a subject a set of operations on a set of target attributes. The subject can be a function, a process, or a node. The operations are an array of string. The target of the deny can be the intersection of a set of containers. It can also be the complement of the logical evaluation of the containers. Each container is identified by a name and type (properties are optional). If more than one node matches the provided name and type all will be taken into account. It is possible to take the complement of an individual container using the complement element. deny: subject: priority goes 1. function, 2. process, 3. node function: --- process: --- name: type: properties: operations: - \"\" - \"\" target: complement: true|false, default false intersection: true|false, default false containers: - name: type: complement: true|false, default false - function: complement: true|false Delete Action Delete assignment relations deny relations grant relations created policy elements created rules yaml delete: create: assign: grant: deny: s Functions Predefined Functions current_user current_process How to add a function How to Extend the Event Pattern","title":"Obligations"},{"location":"obligations/#obligations","text":"Obligations are defined using a yaml syntax described below.","title":"Obligations"},{"location":"obligations/#common-elements","text":"","title":"Common Elements"},{"location":"obligations/#nodes","text":"A node represents a node in an NGAC graph. A node has a name, type, and properties. A node can also be derived from a function. name: type: properties: - key: value","title":"Nodes"},{"location":"obligations/#function","text":"A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Example function: name: args: - \"\" - function: A function has a name and a list of arguments. The arguments are a list of string values or other functions.","title":"function"},{"location":"obligations/#obligation","text":"There is one obligation per yaml file. An obligation can have zero or more rules. label: rules: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules.","title":"Obligation"},{"location":"obligations/#rule","text":"label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event.","title":"Rule"},{"location":"obligations/#event-pattern","text":"event: subject: policyClass: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine.","title":"Event Pattern"},{"location":"obligations/#subject","text":"subject: user: any_user: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event.","title":"Subject"},{"location":"obligations/#user","text":"A user is identified by it's name.","title":"user"},{"location":"obligations/#any_user","text":"any_user: The any_user element accepts an array of strings representing user names. If the element is empty then any user will match.","title":"any_user"},{"location":"obligations/#process","text":"process: The process element accepts a number as a process ID. Example: any_user: # any user ### any_user: # u1 or u2 - \"u1\" - \"u2\" process: 12345","title":"process"},{"location":"obligations/#policy-class","text":"policy_class: anyOf: --- eachOf: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Only one of anyOf and eachOf are allowed. Example ### policyClass: # a;; policy class ### policyClass: # PC1 or PC2 anyOf: - \"PC1\" - \"PC2\" ### policyClass: # PC1 and PC2 eachOf: - \"PC1\" - \"PC2\"","title":"Policy Class"},{"location":"obligations/#operations","text":"operations: - \"operation_name\" The operations specification is a string array of operation names. Any event that matches an element of the array will match the operations event pattern. Example: operations: - \"read\" - \"write\"","title":"Operations"},{"location":"obligations/#target","text":"The target of an event can be A specific policy element policyElements: - name: name type: type Any policy element policyElements: * Omitting policyElements will have the same effect Any policy element that is contained in other policy elements containers: - name: type: - name: type: Any policy element from a set of policy elements policyElements: - name: name type: type - name: name type: type If both policyElements and containers are omitted it will be \"any policyElement in any container\" If containers is present then it will be \"any policyElement in the containers\", regardless of if policyElements is present If policyElements is present its \"any policyElement from the list provided\"","title":"Target"},{"location":"obligations/#response","text":"A response is a series of conditional actions. A condition can also be applied to the response itself.","title":"Response"},{"location":"obligations/#condition","text":"A condition is a set of boolean expressions that if all evaluate to true, allow for a response or specific action to be executed. condition: - function: - function:","title":"Condition"},{"location":"obligations/#create-action","text":"Create 1. A rule 2. A set of nodes and assign them to a set of containers","title":"Create Action"},{"location":"obligations/#rule_1","text":"create: rule: label: event: response:","title":"rule"},{"location":"obligations/#nodes_1","text":"Creating nodes requires the name and type of the nodes to create and the containers in which to assign them. A node can be specified with a set of properties if applicable. create: what: - name: node1 type: UA where: - name: container1 type: UA","title":"nodes"},{"location":"obligations/#assign-action","text":"assign: what: where: The what and where elements are arrays of nodes. The nodes in what will be assigned to the nodes in where .","title":"Assign Action"},{"location":"obligations/#grant-action","text":"Associate each node in subjects with each node in targets . grant: subjects: operations: targets: subjects is an array of nodes that will be the subject of the associations created. operations is an array of operations to add to the associations. targets is an array of nodes that will be the targets of the associations.","title":"Grant Action"},{"location":"obligations/#deny-action","text":"Deny a subject a set of operations on a set of target attributes. The subject can be a function, a process, or a node. The operations are an array of string. The target of the deny can be the intersection of a set of containers. It can also be the complement of the logical evaluation of the containers. Each container is identified by a name and type (properties are optional). If more than one node matches the provided name and type all will be taken into account. It is possible to take the complement of an individual container using the complement element. deny: subject: priority goes 1. function, 2. process, 3. node function: --- process: --- name: type: properties: operations: - \"\" - \"\" target: complement: true|false, default false intersection: true|false, default false containers: - name: type: complement: true|false, default false - function: complement: true|false","title":"Deny Action"},{"location":"obligations/#delete-action","text":"Delete assignment relations deny relations grant relations created policy elements created rules yaml delete: create: assign: grant: deny: s","title":"Delete Action"},{"location":"obligations/#functions","text":"","title":"Functions"},{"location":"obligations/#predefined-functions","text":"current_user current_process","title":"Predefined Functions"},{"location":"obligations/#how-to-add-a-function","text":"","title":"How to add a function"},{"location":"obligations/#how-to-extend-the-event-pattern","text":"","title":"How to Extend the Event Pattern"},{"location":"usage/","text":"Creating a Graph Graph graph = new Graph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. graph.createNode(1234, \"newNode\", NodeType.O, null)); This will add a node with the ID 1234, name \"newNode\", type object, and no properties to the graph. graph.assign(1234, NodeType.O), 4321, NodeType.OA)); Assuming a node with the ID 4321 and type OA have been created in the graph, this will assign the node with ID 1234 to the node with ID 4321. graph.associate(2222, NodeType.UA), 4321, NodeType.OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); Assuming a user attribute node is created with the ID 2222, this will associate it with the object attribute that has the ID 4321, and give the operations read and write. Examples of creating graphs are provided here Access Decisions To make an access decision, instantiate a PReviewDecider which implements the Decider interface. The interface provides several methods to query the current access state of the graph. Decider decider = new PReviewDecider(graph); decider.listPermissions(userID, NO_PROCESS, targetID); The listPermissions method returns the permissions a user has on a target node. Audit Explain Explain answers the question why does a user have access to a given target node? To perform this, instantiate a new PReviewAuditor and call the explain method. Auditor auditor = new PReviewAuditor(graph); Explain explain = auditor.explain(1234, 4321); The result of the explain method is as follows. public class Explain { private Set<String> permissions; private Map<String, PolicyClass> policyClasses; ... } Provided in the result are the permissions the user has on the target node and a map containing the paths from the user to the target under each policy class. A PolicyClass object looks like: public class PolicyClass { private Set<String> operations; private List<Path> paths; ... } The PolicyClass object stores the operations granted to the user under a policy class and the paths that provide those operations. A Path is just a sequence of nodes, starting at the user and ending at the target node: public class Path { private Set<String> operations; private List<Node> nodes; ... } Also provided is the set of operations that the specific path contributes to the overall set for the policy class. Here is the output of an explain example. operations: [read] policyClasses: - pc2: operations: [read] paths: - u1-ua2-oa2-o1 ops=[read] - pc1: operations: [read, write] paths: - u1-ua1-oa1-o1 ops=[read, write] See an example here","title":"Usage"},{"location":"usage/#creating-a-graph","text":"Graph graph = new Graph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. graph.createNode(1234, \"newNode\", NodeType.O, null)); This will add a node with the ID 1234, name \"newNode\", type object, and no properties to the graph. graph.assign(1234, NodeType.O), 4321, NodeType.OA)); Assuming a node with the ID 4321 and type OA have been created in the graph, this will assign the node with ID 1234 to the node with ID 4321. graph.associate(2222, NodeType.UA), 4321, NodeType.OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); Assuming a user attribute node is created with the ID 2222, this will associate it with the object attribute that has the ID 4321, and give the operations read and write. Examples of creating graphs are provided here","title":"Creating a Graph"},{"location":"usage/#access-decisions","text":"To make an access decision, instantiate a PReviewDecider which implements the Decider interface. The interface provides several methods to query the current access state of the graph. Decider decider = new PReviewDecider(graph); decider.listPermissions(userID, NO_PROCESS, targetID); The listPermissions method returns the permissions a user has on a target node.","title":"Access Decisions"},{"location":"usage/#audit","text":"","title":"Audit"},{"location":"usage/#explain","text":"Explain answers the question why does a user have access to a given target node? To perform this, instantiate a new PReviewAuditor and call the explain method. Auditor auditor = new PReviewAuditor(graph); Explain explain = auditor.explain(1234, 4321); The result of the explain method is as follows. public class Explain { private Set<String> permissions; private Map<String, PolicyClass> policyClasses; ... } Provided in the result are the permissions the user has on the target node and a map containing the paths from the user to the target under each policy class. A PolicyClass object looks like: public class PolicyClass { private Set<String> operations; private List<Path> paths; ... } The PolicyClass object stores the operations granted to the user under a policy class and the paths that provide those operations. A Path is just a sequence of nodes, starting at the user and ending at the target node: public class Path { private Set<String> operations; private List<Node> nodes; ... } Also provided is the set of operations that the specific path contributes to the overall set for the policy class. Here is the output of an explain example. operations: [read] policyClasses: - pc2: operations: [read] paths: - u1-ua2-oa2-o1 ops=[read] - pc1: operations: [read, write] paths: - u1-ua1-oa1-o1 ops=[read, write] See an example here","title":"Explain"},{"location":"walkthrough/","text":"PIP The Policy Enforcement Point provides a set of interfaces to persist NGAC policy data. Also provided, are in memory implementations of these interfaces. Graph The Graph interface provides methods to manage and traverse an NGAC graph. Graph graph = new MemGraph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. graph.createNode(1234, \"newNode\", NodeType.O, null)); This will add a node with the ID 1234, name \"newNode\", type object, and no properties to the graph. graph.assign(1234, NodeType.O), 4321, NodeType.OA)); Assuming a node with the ID 4321 and type OA have been created in the graph, this will assign the node with ID 1234 to the node with ID 4321. graph.associate(2222, NodeType.UA), 4321, NodeType.OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); Assuming a user attribute node is created with the ID 2222, this will associate it with the object attribute that has the ID 4321, and give the operations read and write. Prohibitions The Prohibitions interface provides a set of methods to maintain Prohibition relations. Obligations The Obligations interface provides a set of methods to maintain Obligation relations. PDP The Policy Decision Point provides the access control logic to requests on the data stored in the PAP . Decision Making Access Decisions Prohibition Decisions Auditing Explain Creating a Policy Class Creating a Non Policy Class Permissions required for each method Events Assign, deassign, assign to deassign from EPP The Event Processing Point is responsible for reacting to events that occur in the NGAC system. The events can be triggered in the PDP or the PEP (Policy Enforcement Point, not included in this library). Events EventContext Functions PAP The Policy Administration Point is responsible for administering the access control policies. This includes persisting the data in the PIP and providing the underlying policy data to the PDP and EPP.","title":"Code Walkthrough"},{"location":"walkthrough/#pip","text":"The Policy Enforcement Point provides a set of interfaces to persist NGAC policy data. Also provided, are in memory implementations of these interfaces.","title":"PIP"},{"location":"walkthrough/#graph","text":"The Graph interface provides methods to manage and traverse an NGAC graph. Graph graph = new MemGraph(); This will create a new instance of the in memory implementation of the Graph interface. Now it can be populated with nodes, assignments, and associations. graph.createNode(1234, \"newNode\", NodeType.O, null)); This will add a node with the ID 1234, name \"newNode\", type object, and no properties to the graph. graph.assign(1234, NodeType.O), 4321, NodeType.OA)); Assuming a node with the ID 4321 and type OA have been created in the graph, this will assign the node with ID 1234 to the node with ID 4321. graph.associate(2222, NodeType.UA), 4321, NodeType.OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); Assuming a user attribute node is created with the ID 2222, this will associate it with the object attribute that has the ID 4321, and give the operations read and write.","title":"Graph"},{"location":"walkthrough/#prohibitions","text":"The Prohibitions interface provides a set of methods to maintain Prohibition relations.","title":"Prohibitions"},{"location":"walkthrough/#obligations","text":"The Obligations interface provides a set of methods to maintain Obligation relations.","title":"Obligations"},{"location":"walkthrough/#pdp","text":"The Policy Decision Point provides the access control logic to requests on the data stored in the PAP .","title":"PDP"},{"location":"walkthrough/#decision-making","text":"","title":"Decision Making"},{"location":"walkthrough/#access-decisions","text":"","title":"Access Decisions"},{"location":"walkthrough/#prohibition-decisions","text":"","title":"Prohibition Decisions"},{"location":"walkthrough/#auditing","text":"","title":"Auditing"},{"location":"walkthrough/#explain","text":"","title":"Explain"},{"location":"walkthrough/#creating-a-policy-class","text":"","title":"Creating a Policy Class"},{"location":"walkthrough/#creating-a-non-policy-class","text":"","title":"Creating a Non Policy Class"},{"location":"walkthrough/#permissions-required-for-each-method","text":"","title":"Permissions required for each method"},{"location":"walkthrough/#events","text":"Assign, deassign, assign to deassign from","title":"Events"},{"location":"walkthrough/#epp","text":"The Event Processing Point is responsible for reacting to events that occur in the NGAC system. The events can be triggered in the PDP or the PEP (Policy Enforcement Point, not included in this library).","title":"EPP"},{"location":"walkthrough/#events_1","text":"","title":"Events"},{"location":"walkthrough/#eventcontext","text":"","title":"EventContext"},{"location":"walkthrough/#functions","text":"","title":"Functions"},{"location":"walkthrough/#pap","text":"The Policy Administration Point is responsible for administering the access control policies. This includes persisting the data in the PIP and providing the underlying policy data to the PDP and EPP.","title":"PAP"}]}